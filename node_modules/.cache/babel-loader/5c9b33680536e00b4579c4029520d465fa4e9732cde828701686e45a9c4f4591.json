{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\n\n// src/HoverVideoPlayer.tsx\nimport React, { useRef, useImperativeHandle, useEffect, useState, useCallback } from \"react\";\n\n// src/HoverVideoPlayer.styles.ts\nvar expandToFillContainerStyle = {\n  position: \"absolute\",\n  width: \"100%\",\n  height: \"100%\",\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0\n};\nvar containerMatchContentDimensionsStyle = {\n  display: \"inline-block\"\n};\nvar containerSizingStyles = {\n  video: containerMatchContentDimensionsStyle,\n  overlay: containerMatchContentDimensionsStyle,\n  container: null,\n  manual: null\n};\nvar pausedOverlayWrapperSizingStyles = {\n  // Sizing should be based on the video element, so make the overlay\n  // expand to cover the player's container element\n  video: expandToFillContainerStyle,\n  // Sizing should be based on the paused overlay, so set position: relative\n  // to make it occupy space in the document flow\n  overlay: {\n    position: \"relative\"\n  },\n  // Sizing should be based on the player's container element, so make the overlay\n  // expand to cover it\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the overlay\n  manual: null\n};\nvar videoSizingStyles = {\n  // Sizing should be based on the video element, so set display: block\n  // to make sure it occupies space in the document flow\n  video: {\n    display: \"block\",\n    // Ensure the video is sized relative to the container's width\n    // rather than the video asset's native width\n    width: \"100%\"\n  },\n  // Make the video element expand to cover the container if we're sizing\n  // based on the overlay or container\n  overlay: expandToFillContainerStyle,\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the video\n  manual: null\n};\nvar overlayTransitionDurationVar = \"--hvp-overlay-transition-duration\";\nvar visibleOverlayStyles = {\n  visibility: \"visible\",\n  opacity: 1,\n  transitionProperty: \"opacity\",\n  transitionDuration: `var(${overlayTransitionDurationVar})`\n};\nvar hiddenOverlayStyles = {\n  visibility: \"hidden\",\n  opacity: 0,\n  transitionProperty: \"opacity, visibility\",\n  transitionDuration: `var(${overlayTransitionDurationVar}), 0s`,\n  transitionDelay: `0s, var(${overlayTransitionDurationVar})`\n};\n\n// src/HoverVideoPlayer.tsx\nfunction HoverVideoPlayer(_a) {\n  var _b = _a,\n    {\n      videoSrc,\n      videoCaptions = null,\n      focused = false,\n      disableDefaultEventHandling = false,\n      hoverTarget = null,\n      onHoverStart = null,\n      onHoverEnd = null,\n      hoverOverlay = null,\n      pausedOverlay = null,\n      loadingOverlay = null,\n      loadingStateTimeout = 200,\n      overlayTransitionDuration = 400,\n      playbackStartDelay = 0,\n      restartOnPaused = false,\n      unloadVideoOnPaused = false,\n      playbackRangeStart = null,\n      playbackRangeEnd = null,\n      muted = true,\n      volume = 1,\n      loop = true,\n      preload = void 0,\n      crossOrigin = void 0,\n      controls = false,\n      controlsList = void 0,\n      disableRemotePlayback = true,\n      disablePictureInPicture = true,\n      style = void 0,\n      hoverOverlayWrapperClassName = void 0,\n      hoverOverlayWrapperStyle = void 0,\n      pausedOverlayWrapperClassName = void 0,\n      pausedOverlayWrapperStyle = void 0,\n      loadingOverlayWrapperClassName = void 0,\n      loadingOverlayWrapperStyle = void 0,\n      videoId = void 0,\n      videoClassName = void 0,\n      videoRef: forwardedVideoRef = null,\n      videoStyle = void 0,\n      sizingMode = \"video\"\n    } = _b,\n    spreadableProps = __objRest(_b, [\"videoSrc\", \"videoCaptions\", \"focused\", \"disableDefaultEventHandling\", \"hoverTarget\", \"onHoverStart\", \"onHoverEnd\", \"hoverOverlay\", \"pausedOverlay\", \"loadingOverlay\", \"loadingStateTimeout\", \"overlayTransitionDuration\", \"playbackStartDelay\", \"restartOnPaused\", \"unloadVideoOnPaused\", \"playbackRangeStart\", \"playbackRangeEnd\", \"muted\", \"volume\", \"loop\", \"preload\", \"crossOrigin\", \"controls\", \"controlsList\", \"disableRemotePlayback\", \"disablePictureInPicture\", \"style\", \"hoverOverlayWrapperClassName\", \"hoverOverlayWrapperStyle\", \"pausedOverlayWrapperClassName\", \"pausedOverlayWrapperStyle\", \"loadingOverlayWrapperClassName\", \"loadingOverlayWrapperStyle\", \"videoId\", \"videoClassName\", \"videoRef\", \"videoStyle\", \"sizingMode\"]);\n  const containerRef = useRef(null);\n  const videoRef = useRef(null);\n  useImperativeHandle(forwardedVideoRef, () => videoRef.current);\n  useEffect(() => {\n    if (videoRef.current) videoRef.current.muted = muted;\n  }, [muted]);\n  useEffect(() => {\n    if (videoRef.current) videoRef.current.volume = volume;\n  }, [volume]);\n  useEffect(() => {\n    if (videoRef.current) videoRef.current.disableRemotePlayback = disableRemotePlayback;\n  }, [disableRemotePlayback]);\n  useEffect(() => {\n    if (videoRef.current) videoRef.current.disablePictureInPicture = disablePictureInPicture;\n  }, [disablePictureInPicture]);\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (videoElement && playbackRangeStart) {\n      videoElement.currentTime = playbackRangeStart;\n    }\n  }, [playbackRangeStart]);\n  const [hoverTargetElement, setHoverTargetElement] = useState(null);\n  useEffect(() => {\n    let element = containerRef.current;\n    if (hoverTarget) {\n      if (typeof hoverTarget === \"function\") {\n        element = hoverTarget();\n      } else if (hoverTarget instanceof Node) {\n        element = hoverTarget;\n      } else if (hoverTarget && hoverTarget.hasOwnProperty(\"current\")) {\n        element = hoverTarget.current;\n      } else {\n        console.error(\"HoverVideoPlayer was unable to get a usable hover target element. Please check your usage of the `hoverTarget` prop.\");\n      }\n    }\n    setHoverTargetElement(element);\n  }, [hoverTarget]);\n  const nextVideoStartTimeRef = useRef(null);\n  const [isHovering, setIsHovering] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const isHoveringRef = useRef();\n  isHoveringRef.current = isHovering;\n  const playTimeoutRef = useRef();\n  const pauseTimeoutRef = useRef();\n  const cancelTimeouts = useCallback(() => {\n    window.clearTimeout(playTimeoutRef.current);\n    window.clearTimeout(pauseTimeoutRef.current);\n  }, []);\n  const hasPausedOverlay = Boolean(pausedOverlay);\n  const hasHoverOverlay = Boolean(hoverOverlay);\n  const shouldWaitForOverlayTransitionBeforePausing = hasPausedOverlay || hasHoverOverlay;\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!hoverTargetElement || !videoElement) return void 0;\n    const onHoverStart2 = () => {\n      if (isHoveringRef.current) return;\n      cancelTimeouts();\n      setIsHovering(true);\n    };\n    const onHoverEnd2 = () => {\n      cancelTimeouts();\n      setIsHovering(false);\n    };\n    hoverTargetElement.addEventListener(\"hvp:hoverStart\", onHoverStart2);\n    hoverTargetElement.addEventListener(\"hvp:hoverEnd\", onHoverEnd2);\n    return () => {\n      hoverTargetElement.removeEventListener(\"hvp:hoverStart\", onHoverStart2);\n      hoverTargetElement.removeEventListener(\"hvp:hoverEnd\", onHoverEnd2);\n    };\n  }, [cancelTimeouts, hoverTargetElement, overlayTransitionDuration, playbackRangeStart, restartOnPaused, shouldWaitForOverlayTransitionBeforePausing]);\n  const playVideo = useCallback(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n    videoElement.play().catch(error => {\n      if (error.name === \"AbortError\") {\n        return;\n      }\n      if (!videoElement.muted && error.name === \"NotAllowedError\") {\n        console.warn(\"HoverVideoPlayer: Playback with sound was blocked by the browser. Attempting to play again with the video muted; audio will be restored if the user clicks on the page.\");\n        videoElement.muted = true;\n        playVideo();\n        const onClickDocument = () => {\n          videoElement.muted = false;\n          document.removeEventListener(\"click\", onClickDocument);\n        };\n        document.addEventListener(\"click\", onClickDocument);\n      } else {\n        console.error(`HoverVideoPlayer: ${error.message}`);\n      }\n    });\n  }, []);\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n    if (isHovering && !isLoading && !isPlaying) {\n      if (nextVideoStartTimeRef.current !== null && videoElement.currentTime !== nextVideoStartTimeRef.current) {\n        videoElement.currentTime = nextVideoStartTimeRef.current;\n      }\n      if (playbackStartDelay) {\n        playTimeoutRef.current = window.setTimeout(playVideo, playbackStartDelay);\n      } else {\n        playVideo();\n      }\n    }\n  }, [isHovering, isLoading, isPlaying, playVideo, playbackStartDelay]);\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n    if (!isHovering && (isPlaying || isLoading)) {\n      const pauseVideo = () => {\n        videoElement.pause();\n        if (restartOnPaused) {\n          videoElement.currentTime = playbackRangeStart || 0;\n        }\n        nextVideoStartTimeRef.current = videoElement.currentTime;\n      };\n      if (shouldWaitForOverlayTransitionBeforePausing) {\n        pauseTimeoutRef.current = window.setTimeout(pauseVideo, overlayTransitionDuration);\n      } else {\n        pauseVideo();\n      }\n    }\n  }, [isHovering, isLoading, isPlaying, overlayTransitionDuration, playbackRangeStart, restartOnPaused, shouldWaitForOverlayTransitionBeforePausing]);\n  useEffect(() => () => cancelTimeouts(), [cancelTimeouts]);\n  const onHoverStartCallbackRef = useRef();\n  onHoverStartCallbackRef.current = onHoverStart;\n  const onHoverEndCallbackRef = useRef();\n  onHoverEndCallbackRef.current = onHoverEnd;\n  useEffect(() => {\n    if (disableDefaultEventHandling || !hoverTargetElement) return void 0;\n    const onHoverStart2 = () => {\n      var _a2;\n      hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverStart\"));\n      (_a2 = onHoverStartCallbackRef.current) == null ? void 0 : _a2.call(onHoverStartCallbackRef);\n    };\n    const onHoverEnd2 = () => {\n      var _a2;\n      hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverEnd\"));\n      (_a2 = onHoverEndCallbackRef.current) == null ? void 0 : _a2.call(onHoverEndCallbackRef);\n    };\n    hoverTargetElement.addEventListener(\"mouseenter\", onHoverStart2);\n    hoverTargetElement.addEventListener(\"mouseleave\", onHoverEnd2);\n    hoverTargetElement.addEventListener(\"focus\", onHoverStart2);\n    hoverTargetElement.addEventListener(\"blur\", onHoverEnd2);\n    const touchStartListenerOptions = {\n      passive: true\n    };\n    hoverTargetElement.addEventListener(\"touchstart\", onHoverStart2, touchStartListenerOptions);\n    const onWindowTouchStart = event => {\n      if (!(event.target instanceof Node) || !hoverTargetElement.contains(event.target)) {\n        onHoverEnd2();\n      }\n    };\n    window.addEventListener(\"touchstart\", onWindowTouchStart, touchStartListenerOptions);\n    return () => {\n      hoverTargetElement.removeEventListener(\"mouseenter\", onHoverStart2);\n      hoverTargetElement.removeEventListener(\"mouseleave\", onHoverEnd2);\n      hoverTargetElement.removeEventListener(\"focus\", onHoverStart2);\n      hoverTargetElement.removeEventListener(\"blur\", onHoverEnd2);\n      hoverTargetElement.removeEventListener(\"touchstart\", onHoverStart2);\n      window.removeEventListener(\"touchstart\", onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTargetElement]);\n  const previousFocusedRef = useRef(false);\n  useEffect(() => {\n    if (!hoverTargetElement) return;\n    if (previousFocusedRef.current !== focused) {\n      previousFocusedRef.current = focused;\n      if (focused) {\n        hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverStart\"));\n      } else {\n        hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverEnd\"));\n      }\n    }\n  }, [hoverTargetElement, focused]);\n  const currentVideoSrc = useRef(videoSrc);\n  let shouldReloadVideoSrc = false;\n  if (videoSrc !== currentVideoSrc.current && !isHovering && !isPlaying) {\n    currentVideoSrc.current = videoSrc;\n    shouldReloadVideoSrc = true;\n  }\n  const hasStringSrc = typeof currentVideoSrc.current === \"string\";\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n    if (shouldReloadVideoSrc) {\n      videoElement.load();\n      nextVideoStartTimeRef.current = playbackRangeStart || 0;\n    }\n  }, [playbackRangeStart, shouldReloadVideoSrc]);\n  const shouldUnloadVideo = unloadVideoOnPaused && !isHovering && !isPlaying;\n  useEffect(() => {\n    var _a2;\n    if (shouldUnloadVideo) {\n      (_a2 = videoRef.current) == null ? void 0 : _a2.load();\n    }\n  }, [shouldUnloadVideo]);\n  const shouldShowLoadingOverlay = isHovering && !isPlaying;\n  const shouldShowPausedOverlay = !isHovering || isHovering && !isPlaying;\n  const isUsingPlaybackRange = playbackRangeStart !== null || playbackRangeEnd !== null;\n  const hasLoadingOverlay = Boolean(loadingOverlay);\n  return /* @__PURE__ */React.createElement(\"div\", __spreadValues({\n    ref: containerRef,\n    style: __spreadValues(__spreadProps(__spreadValues({\n      [overlayTransitionDurationVar]: `${overlayTransitionDuration}ms`\n    }, containerSizingStyles[sizingMode]), {\n      position: \"relative\"\n    }), style)\n  }, spreadableProps), hasPausedOverlay ? /* @__PURE__ */React.createElement(\"div\", {\n    style: __spreadValues(__spreadValues(__spreadProps(__spreadValues({}, pausedOverlayWrapperSizingStyles[sizingMode]), {\n      zIndex: 1\n    }), shouldShowPausedOverlay ? visibleOverlayStyles : hiddenOverlayStyles), pausedOverlayWrapperStyle),\n    className: pausedOverlayWrapperClassName\n  }, pausedOverlay) : null, hasLoadingOverlay ? /* @__PURE__ */React.createElement(\"div\", {\n    style: __spreadValues(__spreadValues(__spreadProps(__spreadValues({}, expandToFillContainerStyle), {\n      zIndex: 2,\n      transitionDelay: loadingStateTimeout ? `${loadingStateTimeout}ms` : void 0\n    }), shouldShowLoadingOverlay ? visibleOverlayStyles : hiddenOverlayStyles), loadingOverlayWrapperStyle),\n    className: loadingOverlayWrapperClassName\n  }, loadingOverlay) : null, hasHoverOverlay ? /* @__PURE__ */React.createElement(\"div\", {\n    style: __spreadValues(__spreadValues(__spreadProps(__spreadValues({}, expandToFillContainerStyle), {\n      zIndex: 3\n    }), isHovering ? visibleOverlayStyles : hiddenOverlayStyles), hoverOverlayWrapperStyle),\n    className: hoverOverlayWrapperClassName\n  }, hoverOverlay) : null, /* @__PURE__ */React.createElement(\"video\", {\n    src: hasStringSrc && !shouldUnloadVideo ? currentVideoSrc.current : void 0,\n    loop: isUsingPlaybackRange ? false : loop,\n    playsInline: true,\n    preload,\n    crossOrigin,\n    ref: videoRef,\n    style: __spreadValues(__spreadProps(__spreadValues({}, videoSizingStyles[sizingMode]), {\n      objectFit: \"cover\"\n    }), videoStyle),\n    controls,\n    controlsList,\n    className: videoClassName,\n    id: videoId,\n    onPlaying: () => setIsPlaying(true),\n    onPause: () => setIsPlaying(false),\n    onEnded: () => setIsPlaying(false),\n    onLoadStart: () => setIsLoading(true),\n    onSuspend: () => setIsLoading(false),\n    onWaiting: () => setIsLoading(true),\n    onLoadedData: () => {\n      var _a2;\n      setIsLoading((((_a2 = videoRef.current) == null ? void 0 : _a2.readyState) || 0) < HTMLMediaElement.HAVE_ENOUGH_DATA);\n    },\n    onAbort: () => {\n      setIsLoading(false);\n    },\n    onTimeUpdate:\n    // If there's a playback range set, the traditional `loop` video prop won't work correctly so\n    // we'll need watch the video's time as it plays and manually keep it within the bounds of the range\n    isUsingPlaybackRange ? () => {\n      const videoElement = videoRef.current;\n      if (!videoElement) return;\n      const maxVideoTime = playbackRangeEnd || videoElement.duration;\n      const minVideoTime = playbackRangeStart || 0;\n      const {\n        currentTime\n      } = videoElement;\n      if (loop && currentTime >= maxVideoTime) {\n        const startTime = playbackRangeStart || 0;\n        videoElement.currentTime = startTime;\n        if (isHovering && (videoElement.paused || videoElement.ended)) {\n          playVideo();\n        }\n      } else if (currentTime > maxVideoTime) {\n        videoElement.pause();\n        videoElement.currentTime = maxVideoTime;\n      } else if (currentTime < minVideoTime) {\n        videoElement.currentTime = minVideoTime;\n      }\n    } : void 0\n  }, shouldUnloadVideo || hasStringSrc ? null : currentVideoSrc.current, videoCaptions));\n}\nexport { HoverVideoPlayer as default };\n/**\n * @component HoverVideoPlayer\n * @license MIT\n *\n * @param {HoverVideoPlayerProps} props\n */","map":{"version":3,"names":["React","useRef","useImperativeHandle","useEffect","useState","useCallback","expandToFillContainerStyle","position","width","height","top","bottom","left","right","containerMatchContentDimensionsStyle","display","containerSizingStyles","video","overlay","container","manual","pausedOverlayWrapperSizingStyles","videoSizingStyles","overlayTransitionDurationVar","visibleOverlayStyles","visibility","opacity","transitionProperty","transitionDuration","hiddenOverlayStyles","transitionDelay","HoverVideoPlayer","_a","_b","videoSrc","videoCaptions","focused","disableDefaultEventHandling","hoverTarget","onHoverStart","onHoverEnd","hoverOverlay","pausedOverlay","loadingOverlay","loadingStateTimeout","overlayTransitionDuration","playbackStartDelay","restartOnPaused","unloadVideoOnPaused","playbackRangeStart","playbackRangeEnd","muted","volume","loop","preload","crossOrigin","controls","controlsList","disableRemotePlayback","disablePictureInPicture","style","hoverOverlayWrapperClassName","hoverOverlayWrapperStyle","pausedOverlayWrapperClassName","pausedOverlayWrapperStyle","loadingOverlayWrapperClassName","loadingOverlayWrapperStyle","videoId","videoClassName","videoRef","forwardedVideoRef","videoStyle","sizingMode","spreadableProps","__objRest","containerRef","current","videoElement","currentTime","hoverTargetElement","setHoverTargetElement","element","Node","hasOwnProperty","console","error","nextVideoStartTimeRef","isHovering","setIsHovering","isLoading","setIsLoading","isPlaying","setIsPlaying","isHoveringRef","playTimeoutRef","pauseTimeoutRef","cancelTimeouts","window","clearTimeout","hasPausedOverlay","Boolean","hasHoverOverlay","shouldWaitForOverlayTransitionBeforePausing","onHoverStart2","onHoverEnd2","addEventListener","removeEventListener","playVideo","play","catch","name","warn","onClickDocument","document","message","setTimeout","pauseVideo","pause","onHoverStartCallbackRef","onHoverEndCallbackRef","_a2","dispatchEvent","Event","call","touchStartListenerOptions","passive","onWindowTouchStart","event","target","contains","previousFocusedRef","currentVideoSrc","shouldReloadVideoSrc","hasStringSrc","load","shouldUnloadVideo","shouldShowLoadingOverlay","shouldShowPausedOverlay","isUsingPlaybackRange","hasLoadingOverlay","createElement","__spreadValues","ref","__spreadProps","zIndex","className","src","playsInline","objectFit","id","onPlaying","onPause","onEnded","onLoadStart","onSuspend","onWaiting","onLoadedData","readyState","HTMLMediaElement","HAVE_ENOUGH_DATA","onAbort","onTimeUpdate","maxVideoTime","duration","minVideoTime","startTime","paused","ended"],"sources":["/Users/neeharikars/react-netflix-clone/node_modules/react-hover-video-player/src/HoverVideoPlayer.tsx","/Users/neeharikars/react-netflix-clone/node_modules/react-hover-video-player/src/HoverVideoPlayer.styles.ts"],"sourcesContent":["import React, {\n  useRef,\n  useImperativeHandle,\n  useEffect,\n  useState,\n  useCallback,\n} from \"react\";\n\nimport {\n  expandToFillContainerStyle,\n  containerSizingStyles,\n  pausedOverlayWrapperSizingStyles,\n  videoSizingStyles,\n  visibleOverlayStyles,\n  hiddenOverlayStyles,\n  overlayTransitionDurationVar,\n} from \"./HoverVideoPlayer.styles\";\n\nimport { HoverVideoPlayerProps } from \"./HoverVideoPlayer.types\";\n\n/**\n * @component HoverVideoPlayer\n * @license MIT\n *\n * @param {HoverVideoPlayerProps} props\n */\nexport default function HoverVideoPlayer({\n  videoSrc,\n  videoCaptions = null,\n  focused = false,\n  disableDefaultEventHandling = false,\n  hoverTarget = null,\n  onHoverStart = null,\n  onHoverEnd = null,\n  hoverOverlay = null,\n  pausedOverlay = null,\n  loadingOverlay = null,\n  loadingStateTimeout = 200,\n  overlayTransitionDuration = 400,\n  playbackStartDelay = 0,\n  restartOnPaused = false,\n  unloadVideoOnPaused = false,\n  playbackRangeStart = null,\n  playbackRangeEnd = null,\n  muted = true,\n  volume = 1,\n  loop = true,\n  preload = undefined,\n  crossOrigin = undefined,\n  controls = false,\n  controlsList = undefined,\n  disableRemotePlayback = true,\n  disablePictureInPicture = true,\n  style = undefined,\n  hoverOverlayWrapperClassName = undefined,\n  hoverOverlayWrapperStyle = undefined,\n  pausedOverlayWrapperClassName = undefined,\n  pausedOverlayWrapperStyle = undefined,\n  loadingOverlayWrapperClassName = undefined,\n  loadingOverlayWrapperStyle = undefined,\n  videoId = undefined,\n  videoClassName = undefined,\n  videoRef: forwardedVideoRef = null,\n  videoStyle = undefined,\n  sizingMode = \"video\",\n  ...spreadableProps\n}: HoverVideoPlayerProps): JSX.Element {\n  // Element refs\n  const containerRef = useRef<HTMLDivElement>(null);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  // Forward out local videoRef along to the videoRef prop\n  useImperativeHandle(\n    forwardedVideoRef,\n    () => videoRef.current as HTMLVideoElement\n  );\n\n  // Effects set attributes on the video which can't be done via props\n  useEffect(() => {\n    // Manually setting the `muted` attribute on the video element via an effect in order\n    // to avoid a know React issue with the `muted` prop not applying correctly on initial render\n    // https://github.com/facebook/react/issues/10389\n    if (videoRef.current) videoRef.current.muted = muted;\n  }, [muted]);\n  useEffect(() => {\n    // Set the video's volume to match the `volume` prop\n    // Note that this will have no effect if the `muted` prop is set to true\n    if (videoRef.current) videoRef.current.volume = volume;\n  }, [volume]);\n  // React does not support directly setting disableRemotePlayback or disablePictureInPicture directly\n  // via the video element's props, so we have to manually set them in an effect\n  useEffect(() => {\n    if (videoRef.current)\n      videoRef.current.disableRemotePlayback = disableRemotePlayback;\n  }, [disableRemotePlayback]);\n  useEffect(() => {\n    if (videoRef.current)\n      videoRef.current.disablePictureInPicture = disablePictureInPicture;\n  }, [disablePictureInPicture]);\n\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    if (videoElement && playbackRangeStart) {\n      videoElement.currentTime = playbackRangeStart;\n    }\n  }, [playbackRangeStart]);\n\n  const [hoverTargetElement, setHoverTargetElement] = useState<Node | null>(\n    null\n  );\n\n  useEffect(() => {\n    // Default to the container element unless a hoverTarget prop is provided\n    let element: Node | null = containerRef.current;\n\n    if (hoverTarget) {\n      // Get the hover target element from the hoverTarget prop, or default to the component's container div\n      // A `hoverTarget` value could be a function, a DOM element, or a React ref, so\n      // figure out which one it is and get the hover target element out of it accordingly\n      if (typeof hoverTarget === \"function\") {\n        element = hoverTarget();\n      } else if (hoverTarget instanceof Node) {\n        element = hoverTarget;\n      } else if (hoverTarget && hoverTarget.hasOwnProperty(\"current\")) {\n        element = hoverTarget.current;\n      } else {\n        console.error(\n          \"HoverVideoPlayer was unable to get a usable hover target element. Please check your usage of the `hoverTarget` prop.\"\n        );\n      }\n    }\n\n    setHoverTargetElement(element);\n  }, [hoverTarget]);\n\n  // Keep a ref for the time which the video should be started from next time it is played\n  // This is useful if the video gets unloaded and we want to restore it to the time it was\n  // at before if the user tries playing it again\n  const nextVideoStartTimeRef = useRef<number | null>(null);\n\n  // Whether the user is hovering over the hover target, meaning we should be trying to play the video\n  const [isHovering, setIsHovering] = useState(false);\n  // Whether the video is currently in a loading state, meaning it's not ready to be played yet\n  const [isLoading, setIsLoading] = useState(false);\n  // Whether the video is currently playing or not\n  const [isPlaying, setIsPlaying] = useState(false);\n\n  const isHoveringRef = useRef<boolean>();\n  isHoveringRef.current = isHovering;\n\n  const playTimeoutRef = useRef<number | undefined>();\n  const pauseTimeoutRef = useRef<number | undefined>();\n\n  const cancelTimeouts = useCallback(() => {\n    // Cancel any previously active pause or playback attempts\n    window.clearTimeout(playTimeoutRef.current);\n    window.clearTimeout(pauseTimeoutRef.current);\n  }, []);\n\n  const hasPausedOverlay = Boolean(pausedOverlay);\n  const hasHoverOverlay = Boolean(hoverOverlay);\n\n  // If we have a paused or hover overlay, the player should wait\n  // for the overlay(s) to finish transitioning back in before we\n  // pause the video\n  const shouldWaitForOverlayTransitionBeforePausing =\n    hasPausedOverlay || hasHoverOverlay;\n\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    if (!hoverTargetElement || !videoElement) return undefined;\n\n    const onHoverStart = () => {\n      // Bail out if we're already hovering\n      if (isHoveringRef.current) return;\n\n      // Cancel any previously active pause or playback attempts\n      cancelTimeouts();\n\n      setIsHovering(true);\n    };\n    const onHoverEnd = () => {\n      cancelTimeouts();\n\n      setIsHovering(false);\n    };\n\n    hoverTargetElement.addEventListener(\"hvp:hoverStart\", onHoverStart);\n    hoverTargetElement.addEventListener(\"hvp:hoverEnd\", onHoverEnd);\n\n    return () => {\n      hoverTargetElement.removeEventListener(\"hvp:hoverStart\", onHoverStart);\n      hoverTargetElement.removeEventListener(\"hvp:hoverEnd\", onHoverEnd);\n    };\n  }, [\n    cancelTimeouts,\n    hoverTargetElement,\n    overlayTransitionDuration,\n    playbackRangeStart,\n    restartOnPaused,\n    shouldWaitForOverlayTransitionBeforePausing,\n  ]);\n\n  const playVideo = useCallback(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    videoElement.play().catch((error: DOMException) => {\n      // Suppress logging for \"AbortError\" errors, which are thrown when the video is paused while it was trying to play.\n      // These errors are expected and happen often, so they can be safely ignored.\n      if (error.name === \"AbortError\") {\n        return;\n      }\n\n      // Additional handling for when browsers block playback for unmuted videos.\n      // This is unfortunately necessary because most modern browsers do not allow playing videos with audio\n      //  until the user has \"interacted\" with the page by clicking somewhere at least once; mouseenter events\n      //  don't count.\n      // If the video isn't muted and playback failed with a `NotAllowedError`, this means the browser blocked\n      // playing the video because the user hasn't clicked anywhere on the page yet.\n      if (!videoElement.muted && error.name === \"NotAllowedError\") {\n        console.warn(\n          \"HoverVideoPlayer: Playback with sound was blocked by the browser. Attempting to play again with the video muted; audio will be restored if the user clicks on the page.\"\n        );\n        // Mute the video and attempt to play again\n        videoElement.muted = true;\n        playVideo();\n\n        // When the user clicks on the document, unmute the video since we should now\n        // be free to play audio\n        const onClickDocument = () => {\n          videoElement.muted = false;\n\n          // Clean up the event listener so it is only fired once\n          document.removeEventListener(\"click\", onClickDocument);\n        };\n        document.addEventListener(\"click\", onClickDocument);\n      } else {\n        // Log any other playback errors with console.error\n        console.error(`HoverVideoPlayer: ${error.message}`);\n      }\n    });\n  }, []);\n\n  // Effect attempts to start playing the video if the user is hovering over the hover target\n  // and the video is loaded enough to be played\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    if (isHovering && !isLoading && !isPlaying) {\n      if (\n        nextVideoStartTimeRef.current !== null &&\n        videoElement.currentTime !== nextVideoStartTimeRef.current\n      ) {\n        videoElement.currentTime = nextVideoStartTimeRef.current;\n      }\n\n      if (playbackStartDelay) {\n        playTimeoutRef.current = window.setTimeout(\n          playVideo,\n          playbackStartDelay\n        );\n      } else {\n        playVideo();\n      }\n    }\n  }, [isHovering, isLoading, isPlaying, playVideo, playbackStartDelay]);\n\n  // Effect pauses the video if the user is no longer hovering over the hover target\n  // and the video is currently playing\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    if (!isHovering && (isPlaying || isLoading)) {\n      const pauseVideo = () => {\n        videoElement.pause();\n\n        // Performing post-save cleanup tasks in here rather than the onPause listener\n        // because onPause can also be called when the video reaches the end of a playback range\n        // and it's just simpler to deal with that separately\n        if (restartOnPaused) {\n          videoElement.currentTime = playbackRangeStart || 0;\n        }\n        nextVideoStartTimeRef.current = videoElement.currentTime;\n      };\n\n      if (shouldWaitForOverlayTransitionBeforePausing) {\n        // If we have a paused overlay, the player should wait\n        // for the overlay(s) to finish transitioning back in before we\n        // pause the video\n        pauseTimeoutRef.current = window.setTimeout(\n          pauseVideo,\n          overlayTransitionDuration\n        );\n      } else {\n        pauseVideo();\n      }\n    }\n  }, [\n    isHovering,\n    isLoading,\n    isPlaying,\n    overlayTransitionDuration,\n    playbackRangeStart,\n    restartOnPaused,\n    shouldWaitForOverlayTransitionBeforePausing,\n  ]);\n\n  // Effect cancels any pending timeouts when the component unmounts\n  useEffect(() => () => cancelTimeouts(), [cancelTimeouts]);\n\n  // Keeping hover callbacks as refs because we want to be able to access them from within our\n  // onHoverStart and onHoverEnd event listeners without needing to re-run the\n  // event setup effect every time they change\n  const onHoverStartCallbackRef = useRef<typeof onHoverStart>();\n  onHoverStartCallbackRef.current = onHoverStart;\n\n  const onHoverEndCallbackRef = useRef<typeof onHoverEnd>();\n  onHoverEndCallbackRef.current = onHoverEnd;\n\n  // Effect sets up event listeners for hover events on hover target\n  useEffect(() => {\n    // If default event handling is disabled, we shouldn't check for touch events outside of the player\n    if (disableDefaultEventHandling || !hoverTargetElement) return undefined;\n\n    const onHoverStart = () => {\n      hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverStart\"));\n      onHoverStartCallbackRef.current?.();\n    };\n    const onHoverEnd = () => {\n      hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverEnd\"));\n      onHoverEndCallbackRef.current?.();\n    };\n\n    // Mouse events\n    hoverTargetElement.addEventListener(\"mouseenter\", onHoverStart);\n    hoverTargetElement.addEventListener(\"mouseleave\", onHoverEnd);\n\n    // Focus/blur\n    hoverTargetElement.addEventListener(\"focus\", onHoverStart);\n    hoverTargetElement.addEventListener(\"blur\", onHoverEnd);\n\n    // Touch events\n    const touchStartListenerOptions = { passive: true };\n\n    hoverTargetElement.addEventListener(\n      \"touchstart\",\n      onHoverStart,\n      touchStartListenerOptions\n    );\n    // Event listener pauses the video when the user touches somewhere outside of the player\n    const onWindowTouchStart = (event: TouchEvent) => {\n      if (\n        !(event.target instanceof Node) ||\n        !hoverTargetElement.contains(event.target)\n      ) {\n        onHoverEnd();\n      }\n    };\n\n    window.addEventListener(\n      \"touchstart\",\n      onWindowTouchStart,\n      touchStartListenerOptions\n    );\n\n    // Return a cleanup function that removes all event listeners\n    return () => {\n      hoverTargetElement.removeEventListener(\"mouseenter\", onHoverStart);\n      hoverTargetElement.removeEventListener(\"mouseleave\", onHoverEnd);\n      hoverTargetElement.removeEventListener(\"focus\", onHoverStart);\n      hoverTargetElement.removeEventListener(\"blur\", onHoverEnd);\n      hoverTargetElement.removeEventListener(\"touchstart\", onHoverStart);\n      window.removeEventListener(\"touchstart\", onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTargetElement]);\n\n  // Defaulting the ref to false rather than the initial value of the focused prop because\n  // if focused is true initially, we want to run the effect, but if it's false, we don't\n  const previousFocusedRef = useRef<boolean>(false);\n\n  // Effect dispatches hover start/end events on the target element when the focused prop changes\n  useEffect(() => {\n    if (!hoverTargetElement) return;\n\n    if (previousFocusedRef.current !== focused) {\n      previousFocusedRef.current = focused;\n\n      if (focused) {\n        hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverStart\"));\n      } else {\n        hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverEnd\"));\n      }\n    }\n  }, [hoverTargetElement, focused]);\n\n  const currentVideoSrc = useRef(videoSrc);\n  let shouldReloadVideoSrc = false;\n  if (videoSrc !== currentVideoSrc.current && !isHovering && !isPlaying) {\n    currentVideoSrc.current = videoSrc;\n    shouldReloadVideoSrc = true;\n  }\n\n  const hasStringSrc = typeof currentVideoSrc.current === \"string\";\n\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    if (shouldReloadVideoSrc) {\n      // If the video element doesn't have a loaded source or the source has changed since the\n      // last time we played the video, make sure to force the video to load the most up-to-date sources\n      videoElement.load();\n      // Reset the next start time to the start of the video\n      nextVideoStartTimeRef.current = playbackRangeStart || 0;\n    }\n  }, [playbackRangeStart, shouldReloadVideoSrc]);\n\n  // If the video's sources should be unloaded when it's paused and the video is not currently active, we can unload the video's sources.\n  // We will remove the video's <source> tags in this render and then call video.load() in an effect to\n  // fully unload the video\n  const shouldUnloadVideo = unloadVideoOnPaused && !isHovering && !isPlaying;\n\n  useEffect(() => {\n    if (shouldUnloadVideo) {\n      // Re-load the video with the sources removed so we unload everything from memory\n      videoRef.current?.load();\n    }\n  }, [shouldUnloadVideo]);\n\n  const shouldShowLoadingOverlay = isHovering && !isPlaying;\n  // Show a paused overlay when the user isn't hovering or when the user is hovering\n  // but the video is still loading\n  const shouldShowPausedOverlay = !isHovering || (isHovering && !isPlaying);\n\n  const isUsingPlaybackRange =\n    playbackRangeStart !== null || playbackRangeEnd !== null;\n\n  const hasLoadingOverlay = Boolean(loadingOverlay);\n\n  return (\n    <div\n      ref={containerRef}\n      style={{\n        [overlayTransitionDurationVar as string]: `${overlayTransitionDuration}ms`,\n        ...containerSizingStyles[sizingMode],\n        position: \"relative\",\n        ...style,\n      }}\n      {...spreadableProps}\n    >\n      {hasPausedOverlay ? (\n        <div\n          style={{\n            ...pausedOverlayWrapperSizingStyles[sizingMode],\n            zIndex: 1,\n            ...(shouldShowPausedOverlay\n              ? visibleOverlayStyles\n              : hiddenOverlayStyles),\n            ...pausedOverlayWrapperStyle,\n          }}\n          className={pausedOverlayWrapperClassName}\n        >\n          {pausedOverlay}\n        </div>\n      ) : null}\n      {hasLoadingOverlay ? (\n        <div\n          style={{\n            ...expandToFillContainerStyle,\n            zIndex: 2,\n            transitionDelay: loadingStateTimeout\n              ? `${loadingStateTimeout}ms`\n              : undefined,\n            ...(shouldShowLoadingOverlay\n              ? visibleOverlayStyles\n              : hiddenOverlayStyles),\n            ...loadingOverlayWrapperStyle,\n          }}\n          className={loadingOverlayWrapperClassName}\n        >\n          {loadingOverlay}\n        </div>\n      ) : null}\n      {hasHoverOverlay ? (\n        <div\n          style={{\n            ...expandToFillContainerStyle,\n            zIndex: 3,\n            // Show the hover overlay when the player is hovered/playing\n            ...(isHovering ? visibleOverlayStyles : hiddenOverlayStyles),\n            ...hoverOverlayWrapperStyle,\n          }}\n          className={hoverOverlayWrapperClassName}\n        >\n          {hoverOverlay}\n        </div>\n      ) : null}\n      {/* eslint-disable-next-line jsx-a11y/media-has-caption */}\n      <video\n        src={\n          hasStringSrc && !shouldUnloadVideo\n            ? (currentVideoSrc.current as string)\n            : undefined\n        }\n        // If a playback range is set, the loop attribute will not work correctly so there's no point in setting it here;\n        // in that case, we will manually implement this behavior\n        loop={isUsingPlaybackRange ? false : loop}\n        playsInline\n        preload={preload}\n        crossOrigin={crossOrigin}\n        ref={videoRef}\n        style={{\n          ...videoSizingStyles[sizingMode],\n          objectFit: \"cover\",\n          ...videoStyle,\n        }}\n        controls={controls}\n        controlsList={controlsList}\n        className={videoClassName}\n        id={videoId}\n        onPlaying={() => setIsPlaying(true)}\n        onPause={() => setIsPlaying(false)}\n        onEnded={() => setIsPlaying(false)}\n        // Update state when the video starts loading\n        onLoadStart={() => setIsLoading(true)}\n        // Update that we're no longer loading when the video has suspended loading data\n        onSuspend={() => setIsLoading(false)}\n        // Update that we are loading if the video is waiting for data to continue playing\n        onWaiting={() => setIsLoading(true)}\n        onLoadedData={() => {\n          // As video data is loaded, check if we've loaded enough data to start playing the video\n          // and update state accordingly\n          setIsLoading(\n            (videoRef.current?.readyState || 0) <\n              HTMLMediaElement.HAVE_ENOUGH_DATA\n          );\n        }}\n        onAbort={() => {\n          // If loading is aborted, update state\n          setIsLoading(false);\n        }}\n        onTimeUpdate={\n          // If there's a playback range set, the traditional `loop` video prop won't work correctly so\n          // we'll need watch the video's time as it plays and manually keep it within the bounds of the range\n          isUsingPlaybackRange\n            ? () => {\n                const videoElement = videoRef.current;\n                if (!videoElement) return;\n\n                const maxVideoTime = playbackRangeEnd || videoElement.duration;\n                const minVideoTime = playbackRangeStart || 0;\n\n                const { currentTime } = videoElement;\n\n                if (loop && currentTime >= maxVideoTime) {\n                  // If the video should loop and is >= the max video time,\n                  // loop it back around to the start\n                  const startTime = playbackRangeStart || 0;\n                  videoElement.currentTime = startTime;\n\n                  // If the video is paused but the user is still hovering,\n                  // meaning it should continue to play, call play() to keep it going\n                  if (\n                    isHovering &&\n                    (videoElement.paused || videoElement.ended)\n                  ) {\n                    playVideo();\n                  }\n                } else if (currentTime > maxVideoTime) {\n                  // If the video shouldn't loop but we've exceeded the max video time,\n                  // clamp it to the max time and pause it\n                  videoElement.pause();\n                  videoElement.currentTime = maxVideoTime;\n                } else if (currentTime < minVideoTime) {\n                  // If the video's time somehow ended up before the min video time,\n                  // clamp it to the min time\n                  videoElement.currentTime = minVideoTime;\n                }\n              }\n            : undefined\n        }\n      >\n        {shouldUnloadVideo || hasStringSrc ? null : currentVideoSrc.current}\n        {videoCaptions}\n      </video>\n    </div>\n  );\n}\n","import React from 'react';\n\ninterface SizingModeStyle {\n  video: React.CSSProperties | null;\n  overlay: React.CSSProperties | null;\n  container: React.CSSProperties | null;\n  manual: React.CSSProperties | null;\n}\n\n// CSS styles to make some contents in the player expand to fill the container\nexport const expandToFillContainerStyle: React.CSSProperties = {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n};\n\nconst containerMatchContentDimensionsStyle: React.CSSProperties = {\n  display: 'inline-block',\n};\n\nexport const containerSizingStyles: SizingModeStyle = {\n  video: containerMatchContentDimensionsStyle,\n  overlay: containerMatchContentDimensionsStyle,\n  container: null,\n  manual: null,\n};\n\n// Styles to apply to the paused overlay wrapper for each sizing mode\nexport const pausedOverlayWrapperSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so make the overlay\n  // expand to cover the player's container element\n  video: expandToFillContainerStyle,\n  // Sizing should be based on the paused overlay, so set position: relative\n  // to make it occupy space in the document flow\n  overlay: {\n    position: 'relative',\n  },\n  // Sizing should be based on the player's container element, so make the overlay\n  // expand to cover it\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the overlay\n  manual: null,\n};\n\n// Styles to apply to the video element for each sizing mode\nexport const videoSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so set display: block\n  // to make sure it occupies space in the document flow\n  video: {\n    display: 'block',\n    // Ensure the video is sized relative to the container's width\n    // rather than the video asset's native width\n    width: '100%',\n  },\n  // Make the video element expand to cover the container if we're sizing\n  // based on the overlay or container\n  overlay: expandToFillContainerStyle,\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the video\n  manual: null,\n};\n\nexport const overlayTransitionDurationVar = \"--hvp-overlay-transition-duration\";\n\nexport const visibleOverlayStyles: React.CSSProperties = {\n  visibility: 'visible',\n  opacity: 1,\n  transitionProperty: 'opacity',\n  transitionDuration: `var(${overlayTransitionDurationVar})`,\n};\n\nexport const hiddenOverlayStyles: React.CSSProperties = {\n  visibility: 'hidden',\n  opacity: 0,\n  transitionProperty: 'opacity, visibility',\n  transitionDuration: `var(${overlayTransitionDurationVar}), 0s`,\n  transitionDelay: `0s, var(${overlayTransitionDurationVar})`,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}